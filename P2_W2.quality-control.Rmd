# Quality Control

## Motivation

Low-quality scRNA-seq libraries can arise from a variety of sources such as cell damage during dissociation
or failure in library preparation (e.g., during reverse transcription or PCR amplification).
These usually manifest as "cells" with low total counts, few expressed genes and high mitochondrial or spike-in proportions.
These low-quality cells are problematic as they can yield misleading results in downstream analyses.

- They can forming their own distinct cluster(s), complicating interpretation of the results.
This can be most obviously driven by increased mitochondrial proportions or enrichment for nuclear RNAs after cell damage.
However, very small libraries can also form their own clusters due to shifts in the mean expression upon log-transformation.
- They contain genes that appear to be strongly "upregulated", again complicating interpretation.
This is most problematic if some transcripts are present at constant levels in the ambient solution for all libraries.
Small counts will then be greatly inflated upon normalization to offset the small library sizes of low-quality cells.
- They containing genes that appear to be strongly "downregulated" due to the loss of RNA upon cell damage.
This seems most pronounced with ribosomal protein genes, though other cytoplasmic transcripts are likely to be affected.
- They distort the characterization of population heterogeneity during variance estimation or principal components analysis.
The first few principal components will capture differences in quality rather than biology, 
reducing the effectiveness of dimensionality reduction.
Similarly, genes with the largest variances will be driven by differences between low- and high-quality cells.

To avoid - or at least mitigate - these problems, we need to remove these cells at the start of the analysis.
This step is commonly referred to as quality control (QC) on the cells.
(We will use "libraries" and "cells" interchangeably in this section.)

## Introducing the dataset

We will demonstrate the application of various QC procedures using a small scRNA-seq dataset from @lun2017assessing.
This dataset contains SMART-seq2 data with spike-ins from two 96-well plates of 416B cells
with and without induction of the _CBFB-MYH11_ oncogene.
All libraries are provided with no prior quality control, allowing us to apply our own procedures as desired.

```{r}
# NOTE: to be moved to ExperimentHub. 
# Bear with it for now.

library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
lun.zip <- bfcrpath(bfc, 
    file.path("https://www.ebi.ac.uk/arrayexpress/files",
        "E-MTAB-5522/E-MTAB-5522.processed.1.zip"))
lun.sdrf <- bfcrpath(bfc, 
    file.path("https://www.ebi.ac.uk/arrayexpress/files",
        "E-MTAB-5522/E-MTAB-5522.sdrf.txt"))
unzip(lun.zip, exdir=tempdir())

plate1 <- read.delim(file.path(tempdir(), "counts_Calero_20160113.tsv"), 
    header=TRUE, row.names=1, check.names=FALSE)
plate2 <- read.delim(file.path(tempdir(), "counts_Calero_20160325.tsv"), 
    header=TRUE, row.names=1, check.names=FALSE)

gene.lengths <- plate1$Length # First column is the gene length.
plate1 <- as.matrix(plate1[,-1]) # Discarding gene length (as it is not a cell).
plate2 <- as.matrix(plate2[,-1])
rbind(Plate1=dim(plate1), Plate2=dim(plate2))

all.counts <- cbind(plate1, plate2)

library(SingleCellExperiment)
sce <- SingleCellExperiment(list(counts=all.counts))
rowData(sce)$GeneLength <- gene.lengths

isSpike(sce, "ERCC") <- grepl("^ERCC", rownames(sce))
summary(isSpike(sce, "ERCC"))

is.sirv <- grepl("^SIRV", rownames(sce))

metadata <- read.delim(lun.sdrf, check.names=FALSE, header=TRUE)
m <- match(colnames(sce), metadata[["Source Name"]]) # Enforcing identical order.
stopifnot(all(!is.na(m))) # Checking that nothing's missing.
metadata <- metadata[m,]
head(colnames(metadata))

colData(sce)$Plate <- factor(metadata[["Factor Value[block]"]])
pheno <- metadata[["Factor Value[phenotype]"]]
levels(pheno) <- c("induced", "control")
colData(sce)$Oncogene <- pheno
table(colData(sce)$Oncogene, colData(sce)$Plate)

# library(scRNAseq)
# sce <- LunSpikeInData(type="416B") # TODO: this will replace the above.
sce
```

## Choice of QC metrics

We use several common QC metrics to identify low-quality cells.
(While these metrics are described below in terms of reads for SMART-seq2 data, the same definitions apply for UMIs in other technologies like MARS-seq and 10X.)

- The library size is defined as the total sum of counts across all features, i.e., genes and spike-in transcripts.
Cells with small library sizes are of low quality as the RNA has not been efficiently captured (i.e., converted into cDNA and amplified) during library preparation.
- The number of expressed features in each cell is defined as the number of features with non-zero counts for that cell.
Any cell with very few expressed genes is likely to be of poor quality as the diverse transcript population has not been successfully captured.
- The proportion of reads mapped to spike-in transcripts is calculated relative to the library size for each cell.
High proportions are indicative of poor-quality cells, where endogenous RNA has been lost during processing (e.g., due to partial cell lysis or RNA degradation during dissociation).
The same amount of spike-in RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA.
- In the absence of spike-in transcripts, the proportion of reads mapped to genes in the mitochondrial genome can be used.
High proportions are indicative of poor-quality cells [@islam2014quantitative;@ilicic2016classification], possibly because of loss of cytoplasmic RNA from perforated cells.
The reasoning is that mitochondria are larger than individual transcript molecules 
and less likely to escape through tears in the cell membrane.

For each cell, we calculate these quality control metrics using the `calculateQCMetrics` function from the `r BiocStyle::Biocpkg("scater")` package [@mccarthy2017scater].
These are stored in the row- and column-wise metadata of the `SingleCellExperiment` for future reference.

```{r}
# Identifying the mitochondrial transcripts:
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
location <- mapIds(TxDb.Mmusculus.UCSC.mm10.ensGene, 
    keys=rownames(sce), column="CDSCHROM", keytype="GENEID")
is.mito <- which(location=="chrM")

# Computing the QC metrics.
library(scater)
sce <- calculateQCMetrics(sce, feature_controls=list(Mito=is.mito))
head(colnames(rowData(sce)))
head(colnames(colData(sce)))
```

## Identifying low-quality cells

### With fixed thresholds

The simplest approach to identifying low-quality cells is to apply thresholds on the QC metrics.
For example, we might discard all cells that have library sizes below 100,000 reads; express fewer than 5,000 genes; have spike-in proportions above 10%; or have mitochondrial proportions above 5%.

```{r}
qc.lib <- sce$total_counts < 1e5
qc.nexprs <- sce$total_features_by_counts < 5e3
qc.spike <- sce$pct_counts_ERCC > 10
qc.mito <- sce$pct_counts_Mito > 5
discard <- qc.lib | qc.nexprs | qc.spike | qc.mito

# Summarize the number of cells removed for each reason.
DataFrame(LibSize=sum(qc.lib), NExprs=sum(qc.nexprs),
    SpikeProp=sum(qc.spike), MitoProp=sum(qc.mito), Total=sum(discard))

# Retain only high-quality cells in the SingleCellExperiment.
filtered <- sce[,!discard]
filtered
```

While simple, this strategy generally requires considerable experience to determine appropriate thresholds for each experimental protocol and biological system.
For example, thresholds for read count-based data are simply not applicable for UMI-based data, and vice versa.
Indeed, even with the same protocol and system, the appropriate threshold can vary from run to run due to the vagaries of cDNA capture efficiency and sequencing depth.

### With adaptive thresholds

To obtain an adaptive threshold, we assume that most of the dataset consists of high-quality cells.
We then identify cells that are outliers for the various QC metrics.
Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells.
This is loosely motivated by the fact that such a filter will retain 99% of non-outlier values in a Normal distribution.

For the 416B data, we remove cells with log-library sizes that are more than 3 MADs below the median. 
We also remove cells where the log-transformed number of expressed genes is 3 MADs below the median.
A log-transformation is used to improve resolution at small values when `type="lower"`.
It ensures that the threshold is not a negative value, which would be meaningless for any quality control.

```{r}
qc.lib2 <- isOutlier(log(sce$total_counts), nmads=3, type="lower")
qc.nexprs2 <- isOutlier(log(sce$total_features_by_counts), nmads=3,
    type="lower")
```

We identify outliers for the proportion-based metrics in a similar manner.
Here, no transformation is required as we are identifying large outliers that should already be clearly distinguishable from zero.

```{r}
qc.spike2 <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher")
qc.mito2 <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher")
```

We use all of these filters to identify and remove low-quality cells.

```{r}
discard2 <- qc.lib2 | qc.nexprs2 | qc.spike2 | qc.mito2

# Summarize the number of cells removed for each reason.
DataFrame(LibSize=sum(qc.lib2), NExprs=sum(qc.nexprs2),
    SpikeProp=sum(qc.spike2), MitoProp=sum(qc.mito2), Total=sum(discard2))

# Retain only high-quality cells in the SingleCellExperiment.
filtered2 <- sce[,!discard2]
```

With this strategy, the thresholds adapt to both the location and spread of the distribution of values for a given metric.
This allows the QC procedure to adjust to changes in sequencing depth, cDNA capture efficiency, mitochondrial content, etc. without requiring any user intervention or prior experience.
However, some implicit assumptions are required - these are discussed below in more detail.

**Comments:**

- `isOutlier()` will also return the exact filter thresholds for each metric.
These may be useful for checking whether the automatically selected thresholds are appropriate.

    ```{r}
    attr(qc.lib2, "thresholds")
    attr(qc.nexprs2, "thresholds")
    ```

### Considering experimental factors 

More complex studies may involve batches of cells generated at different times or in different systems.
In such cases, the adaptive strategy should be applied to each batch separately. 
It makes little sense to compute medians and MADs from a mixture distribution involving observations from multiple batches.
For example, if the sequencing coverage is lower in one batch compared to the others, it will drag down the median and inflate the MAD.
This will reduce the suitability of the adaptive threshold for the other batches.

If each batch is represented by its own `SingleCellExperiment`, the `isOutlier()` function can be directly applied as shown above.
However, if cells from all batches have been merged into a single `SingleCellExperiment`, the `batch=` argument should be used to ensure that outliers are identified _within_ each batch.
This allows `isOutlier()` to accommodate systematic differences in the QC metrics across batches.

We will again illustrate using the 416B dataset, which actually contains two experimental factors - plate of origin and oncogene induction status.
(We had been ignoring this in the previous section for simplicity, but now we cast our willful ignorance aside.)
We combine these factors together and supply this to the `batch=` argument.
This results in the removal of more cells as the MAD is no longer inflated by (i) systematic differences in sequencing depth between batches and (ii) differences in number of genes expressed upon oncogene induction.

```{r}
batch <- paste0(sce$Oncogene, "-", sce$Plate)

qc.lib3 <- isOutlier(log(sce$total_counts), nmads=3, type="lower",
    batch=batch)
qc.nexprs3 <- isOutlier(log(sce$total_features_by_counts), nmads=3,
    type="lower", batch=batch)
qc.spike3 <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher",
    batch=batch)
qc.mito3 <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher",
    batch=batch)

discard3 <- qc.lib3 | qc.nexprs3 | qc.spike3 | qc.mito3

# Summarize the number of cells removed for each reason.
DataFrame(LibSize=sum(qc.lib3), NExprs=sum(qc.nexprs3),
    SpikeProp=sum(qc.spike3), MitoProp=sum(qc.mito3), Total=sum(discard3))

# Retain only high-quality cells in the SingleCellExperiment.
filtered3 <- sce[,!discard3]
```
## Checking diagnostic plots

TODO.

## Assumptions of outlier detection

An outlier-based definition for low-quality cells assumes that most cells are of acceptable quality.
This is usually a reasonable expectation and can be experimentally supported in some situations by visually checking that the cells are intact, e.g., on the microwell plate.
If most cells are of (unacceptably) low quality, the adaptive thresholds will fail as they cannot remove the majority of cells.
Of course, what is acceptable or not is in the eye of the beholder -
neurons, for example, are notoriously difficult to dissociate, and we would often retain cells in a neuronal scRNA-seq dataset with QC metrics that would be unacceptable in a more amenable system.

Another assumption is that the QC metrics are independent of the biological state of each cell.
This implies that any outlier values for these metrics are driven by technical factors rather than biological processes.
Thus, removing cells based on the metrics will not misrepresent the biology in downstream analyses.
This assumption is most likely to be violated in highly heterogeneous cell populations.
For example, some cell types may naturally have less RNA or express fewer genes than other cell types.
These cell types are more likely to be considered outliers and removed, even if they are of high quality.
QC filtering based on outliers may not be appropriate in such cases. 

The use of the MAD mitigates this problem by accounting for biological variability in the QC metrics.
A heterogeneous population should have higher variability in the metrics among high-quality cells, increasing the MAD and reducing the chance of incorrectly removing particular cell types (at the cost of reducing power to remove low-quality cells).
Systematic differences in the QC metrics can be handled to some extent using the `batch=` argument in the `isOutlier()` function.
However, this is not applicable in experiments where the relevant factors (e.g., cell type) are not known in advance.
