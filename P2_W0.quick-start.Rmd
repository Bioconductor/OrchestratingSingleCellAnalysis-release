# Quick Start

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE, warning = FALSE, error = FALSE,
                      cache = TRUE,
                      dev = 'CairoPNG')                      
options(digits = 4)
library(BiocStyle)
```

To make it as easy as possible to get started fast, here we simply provide a script that walks through a typical, basic scRNA-seq analysis in code, with prose as comments (`#`), and all visualization held until the end of the script. The next chapter - "A Basic Analysis" - will provide more commentary on the various steps throughout, as well as relevant intermediate plotting results. 

Here, we use an example dataset from the [*Human Cell Atlas* immune cell profiling project on bone marrow](https://preview.data.humancellatlas.org). This dataset is loaded via the *HCAData* package, which provides a ready to use *SingleCellExperiment* object. 

Note that the *HCAData* bone marrow dataset is comprised of 8 donors, so we have added an integration step to ameliorate batch effects caused by different donors. However, for use cases where integration is not necessary (e.g. no expected batch effects), we note in the code what to skip and relevant arguments to replace.

Lastly, note that some arguments are added for the sake of reducing computational runtime and can be modified or removed. These include parallelization via `BPPARAM`, and different algorithms for SVD and nearest-neighbor via `BSPARAM` and `BNPARAM`. See the "Adaptations for Large-scale Data" chapter for more information on these arguments.


```{r}
## Setup ---------------------------------------------------
## not run - uncomment these lines to install necessary pkgs

## install.packages('BiocManager')
## BiocManager::install(version = 'devel') # devel=3.10
## BiocManager::install(c(
##   'HCAData',                       # dataset
##   'scater', 'scran', 'batchelor',  # processing
##   'igraph',                        # clustering
##   'MAST', 'slingshot',             # DE + Trajectory
##   'iSEE'                           # interactive viz
## ))

## Import data into R --------------------------------------

## For reading in data directly from CellRanger output
## use the lines below and replace with proper paths to data
## append any cell metadata as needed to colData()
## library(DropletUtils)
## sce <- read10xCounts('/path/to/cellranger/outs/')

## For this quick-start: Human Cell Atlas (HCA) data
library(HCAData)
sce <- HCAData('ica_bone_marrow')

## subsample for better brevity of compilation
set.seed(1234)
sce <- sce[, sample(ncol(sce), 10000)]

## Split out donor based on barcode
Donor <- lapply(sce$Barcode, strsplit, '_')
Donor <- unlist(lapply(Donor, function(x) { x[[1]][1] }))
sce$Donor <- Donor

## Convert DelayedArray to regular matrix
counts(sce) <- as.matrix(counts(sce))

## Quality Control -----------------------------------------
library(scater)
sce <- calculateQCMetrics(sce,
                          BPPARAM = BiocParallel::MulticoreParam())

## remove "bad" cells by total counts/features per cell
filt_lgl <- sce$total_counts > 500 & sce$total_features_by_counts > 100
sce <- sce[, filt]

## to ease computation, remove low frequency genes from `sce`
num_reads <- 1                  # minimum 1 read
num_cells <- 0.025 * ncol(sce)   # in at least 2.5% of all cells
keep <- rowSums(counts(sce) >= num_reads) >= num_cells
sce <- sce[keep, ]

## for readability, use Symbols in lieu of IDs as rownames
uniq_feats <- uniquifyFeatureNames(ID = rowData(sce)$ID,
                                   names = rowData(sce)$Symbol)
rownames(sce) <- uniq_feats


## Normalization -------------------------------------------
sce <- normalize(sce)


## Feature Selection ---------------------------------------
library(scran)

fit <- trendVar(sce, use.spikes = FALSE)
dec <- decomposeVar(sce, fit)
hvg <- rownames(dec)[dec$bio > 0] # save gene names


## Integration ---------------------------------------------
## only perform this section if there is a batch effect
library(batchelor)

mnn <- fastMNN(sce, batch = sce$Donor,
               subset.row = hvg,
               BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE),
               BNPARAM = BiocNeighbors::AnnoyParam(),
               BPPARAM = BiocParallel::MulticoreParam())

reducedDim(sce, 'MNN') <- reducedDim(mnn, 'corrected')

## Dimensionality Reduction --------------------------------
## note on `use_dimred` arg: specifies which precomputed
## dimension reduction to use in `sce`; if there is none,
## it will first calculate and save PCA to `sce` then UMAP
sce <- runUMAP(sce,
               use_dimred = 'MNN', # omit if `fastMNN()` not run
               BNPARAM = BiocNeighbors::AnnoyParam(),
               BPPARAM = BiocParallel::MulticoreParam(),
               ## unnecessary options, only used to make a pretty graph
               min_dist = 0.5, repulsion_strength = 0.25,
               spread = 0.6,
               n_neighbors = 15)



## Clustering ----------------------------------------------
library(igraph)

## replace `use.dimred` with 'PCA' if no integration was performed
## this will be automatically added via `runUMAP` above
g <- buildSNNGraph(sce, use.dimred = 'MNN',
                   k = 30,  # higher = bigger clusters
                   BNPARAM = BiocNeighbors::AnnoyParam(),
                   BPPARAM = BiocParallel::MulticoreParam())
clusters <- as.factor(igraph::cluster_louvain(g)$membership)
sce$clusters <- clusters


## Differential Expression ---------------------------------
markers <- findMarkers(sce, clusters = sce$clusters,
                       block = sce$Donor, # use to get within-donor DE
                       direction = 'up', lfc = 1.5,
                       pval.type = "all", # get cluster-unique markers
                       subset.row = hvg,
                       BPPARAM = BiocParallel::MulticoreParam())



## library(MAST)
## todo: write MAST func to comparing just two clusters


## Annotation ----------------------------------------------
## todo: figure out what cell types are present
## use a simple marker panel?


## Trajectory Analysis -------------------------------------
## library(slingshot)
## todo: within a cluster, run slingshot for funsies


## Interactive Exploration ---------------------------------
library(iSEE)
## iSEE(sce) ## not run; opens a web browser GUI
```

```{r}
## Visualizations ------------------------------------------
## todo: need the following:
## quality control: histogram of total counts
## normalization: ???
## feature selection: variance v mean expression?
## PCA/UMAP: before and after batch correction
## UMAP (no colours)
## UMAP (with clusters colours)
## UMAP (with cell type labels)
## heatmap (top marker genes)
## trajectory plot (all or on subset of cells/within a clust)
## DE (volcano plot)


## Pre-batch correction
tmp <- runPCA(sce,
              BSPARAM = BiocSingular::IrlbaParam(),
              BPPARAM = BiocParallel::MulticoreParam())
tmp <- runUMAP(tmp,
               BNPARAM = BiocNeighbors::AnnoyParam(),
               BPPARAM = BiocParallel::MulticoreParam())
plotUMAP(tmp, colour_by = 'Donor')


## UMAP plots by different characteristics
plotUMAP(sce, colour_by = 'Donor')
plotUMAP(sce, colour_by = 'CD3E')
plotUMAP(sce, colour_by = 'CD79A')
plotUMAP(sce, colour_by = 'LYZ')
plotUMAP(sce, colour_by = 'NKG7')
plotUMAP(sce, colour_by = 'CD8B')
plotUMAP(sce, colour_by = 'IL7R')
plotUMAP(sce, colour_by = 'HBB')
plotUMAP(sce, colour_by = 'MT-ND3')

plotUMAP(sce, colour_by = 'clusters', text_by = 'clusters')




## Top global markers per cluster
top_markers <- lapply(markers, function(x) {
    rownames(x)[1:20]
})

top_markers <- sort(unique(unlist(top_markers)))
top_markers <- top_markers[!grepl('MT-|^RP', top_markers)]

set.seed(1234)
plotHeatmap(sce[, sample(ncol(sce), 5000)],
            features = top_markers,
            color = viridis::viridis(101, option = 'A'),
##            symmetric = TRUE, zlim = c(-5, 5),
            colour_columns_by = 'clusters',
            clustering_method = 'ward.D2',
            show_colnames = FALSE,
            fontsize_row = 4
            )


## Volcano plot - not run
marker_tbl_1 <- as.data.frame(markers[[1]])

marker_tbl_1 %>%
    ggplot(aes(x = logFC.2, y = -log10(FDR))) +
    geom_point() +
    geom_vline(xintercept = c(-log(1.5), log(1.5)), linetype = 'dashed') +
    theme_classic()



```
