---
output:
  html_document
bibliography: ../ref.bib
---

# Interactive data exploration {#interactive-sharing}

<script>
document.addEventListener("click", function (event) {
    if (event.target.classList.contains("aaron-collapse")) {
        event.target.classList.toggle("active");
        var content = event.target.nextElementSibling;
        if (content.style.display === "block") {
          content.style.display = "none";
        } else {
          content.style.display = "block";
        }
    }
})
</script>

<style>
.aaron-collapse {
  background-color: #eee;
  color: #444;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.aaron-content {
  padding: 0 18px;
  display: none;
  overflow: hidden;
  background-color: #f1f1f1;
}
</style>

## Motivation

Exploratory data analysis (EDA) and visualization are crucial for many aspects of data analysis such as quality control, hypothesis generation and contextual result interpretation.
Single-cell 'omics datasets generated with modern high-throughput technologies are no exception, especially given their increasing size and complexity.
The need for flexible and interactive platforms to explore those data from various perspectives has contributed to the increasing popularity of graphical user interfaces (GUIs) for interactive visualization.

In this chapter, we illustrate how the Bioconductor package *[iSEE](https://bioconductor.org/packages/3.11/iSEE)* can be used to perform some common exploratory tasks during single-cell analysis workflows.
We note that these are examples only; in practice, EDA is often context-dependent and driven by distinct motivations and hypotheses for every new data set.
To this end, `iSEE` provides a flexible framework that is immediately compatible with a wide range of genomics data modalities and can be easily customized to focus on key aspects of individual data sets.

## Quick start {#interactive-quickstart}

An instance of an interactive `iSEE` application can be launched with any data set that is stored in an object of the `SummarizedExperiment` class (or any class that extends it, e.g., `SingleCellExperiment`, `DESeqDataSet`, `MethylSet`).
In its simplest form, this is done simply by calling `iSEE(sce)` with the `sce` data object as the sole argument, as demonstrated here with the 10X PBMC dataset.

<button class="aaron-collapse">View history</button>
<div class="aaron-content">
   
```r
#--- loading ---#
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
raw.path <- bfcrpath(bfc, file.path("http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"))
untar(raw.path, exdir=file.path(tempdir(), "pbmc4k"))

library(DropletUtils)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names=TRUE)

#--- gene-annotation ---#
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol)

library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce.pbmc)$ID, 
    column="SEQNAME", keytype="GENEID")

#--- cell-detection ---#
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[,which(e.out$FDR <= 0.001)]

#--- quality-control ---#
stats <- perCellQCMetrics(sce.pbmc, subsets=list(Mito=which(location=="MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type="higher")
sce.pbmc <- sce.pbmc[,!high.mito]

#--- normalization ---#
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster=clusters)
sce.pbmc <- logNormCounts(sce.pbmc)

#--- variance-modelling ---#
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)

#--- dimensionality-reduction ---#
set.seed(10000)
sce.pbmc <- denoisePCA(sce.pbmc, subset.row=top.pbmc, technical=dec.pbmc)

set.seed(100000)
sce.pbmc <- runTSNE(sce.pbmc, dimred="PCA")

set.seed(1000000)
sce.pbmc <- runUMAP(sce.pbmc, dimred="PCA")

#--- clustering ---#
g <- buildSNNGraph(sce.pbmc, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership
colLabels(sce.pbmc) <- factor(clust)
```

</div>


```r
library(iSEE)
iSEE(sce.pbmc)
```

The default interface contains up to eight built-in panels, each displaying a particular aspect of the data set. 
The layout of panels in the interface may be altered interactively - panels can be added, removed, resized or repositioned using the "Organize panels" menu in the top right corner of the interface. 
The initial layout of the application can also be altered programmatically as described in the rest of this Chapter.

To familiarize themselves with the GUI, users can launch an interactive tour from the menu in the top right corner.
In addition, custom tours can be written to substitute the default built-in tour.
This feature is particularly useful to disseminate new data sets with accompanying bespoke explanations guiding users through the salient features of any given data set (see Section \@ref{dissemination}).

It is also possible to deploy "empty" instances of `iSEE` apps, where any `SummarizedExperiment` object stored in an RDS file may be uploaded to the running application.
Once the file is uploaded, the application will import the `sce` object and initialize the GUI panels with the contents of the object for interactive exploration.
This type of `iSEE` applications is launched without specifying the `sce` argument, as shown below.


```r
iSEE()
```

## Usage examples {#isee-examples}

### Quality control

In this example, we demonstrate that an `iSEE` app can be configured to focus on quality control metrics.
Here, we are interested in two plots:

- The library size of each cell in decreasing order.
An elbow in this plot generally reveals the transition between good quality cells and low quality cells or empty droplets.
- A dimensionality reduction result (in this case, we will pick $t$-SNE) where cells are colored by the log-library size.
This view identifies trajectories or clusters associated with library size and can be used to diagnose QC/normalization problems.
Alternatively, it could also indicate the presence of multiple cell types or states that differ in total RNA content.

In addition, by setting the `ColumnSelectionSource` parmaeter, any point selection made in the _Column data plot_ panel will highlight the corresponding points in the _Reduced dimension plot_ panel.
A user can then select the cells with either large or small library sizes to inspect their distribution in low-dimensional space.


```r
copy.pbmc <- sce.pbmc

# Computing various QC metrics; in particular, the log10-transformed library
# size for each cell and the log-rank by decreasing library size
library(scater)
copy.pbmc <- addPerCellQC(copy.pbmc, exprs_values="counts")
copy.pbmc$log10_total_counts <- log10(copy.pbmc$total)
copy.pbmc$total_counts_rank <- rank(-copy.pbmc$total)

initial.state <- list(
    # Configure a "Column data plot" panel
    ColumnDataPlot(YAxis="log10_total_counts",
        XAxis="Column data",
        XAxisColumnData="total_counts_rank",
        DataBoxOpen=TRUE,
        PanelId=1L),

    # Configure a "Reduced dimension plot " panel
    ReducedDimensionPlot(
        Type="TSNE",
        VisualBoxOpen=TRUE,
        DataBoxOpen=TRUE,
        ColorBy="Column data",
        ColorByColumnData="log10_total_counts",
        SelectionBoxOpen=TRUE,
        ColumnSelectionSource="ColumnDataPlot1")
)

# Prepare the app
app <- iSEE(copy.pbmc, initial=initial.state)
```

The configured Shiny app can then be launched as shown below, or by simply printing the `app` object.


```r
shiny::runApp(app)
```

This app remains fully interactive, i.e., users can interactively control the settings and layout of the panels.
For instance, users may choose to color data points by percentage of UMI mapped to mitochondrial genes (`"pct_counts_Mito"`) in the _Reduced dimension plot_.
Using the transfer of point selection between panels, users could select cells with small library sizes in the _Column data plot_ and highlight them in the _Reduced dimension plot_, to investigate a possible relation between library size, clustering and proportion of reads mapped to mitochondrial genes.

### Annotation of cell populations

In this example, we use `iSEE` to interactively examine the marker genes to conveniently determine cell identities.
We identify upregulated markers in each cluster (Chapter \@ref(marker-detection)) and collect the log-$p$-value for each gene in each cluster.
These are stored in the `rowData` slot of the `SingleCellExperiment` object for access by `iSEE`.


```r
copy.pbmc <- sce.pbmc

library(scran)
markers.pbmc.up <- findMarkers(copy.pbmc, direction="up", 
    log.p=TRUE, sorted=FALSE)

# Collate the log-p-value for each marker in a single table
all.p <- lapply(markers.pbmc.up, FUN = "[[", i="log.p.value")
all.p <- DataFrame(all.p, check.names=FALSE)
colnames(all.p) <- paste0("cluster", colnames(all.p))

# Store the table of results as row metadata
rowData(copy.pbmc) <- cbind(rowData(copy.pbmc), all.p)
```

The next code chunk sets up an app that contains:

1. A table of feature statistics, including the log-transformed FDR of cluster markers computed above.
2. A plot showing the distribution of expression values for a chosen gene in each cluster.
3. A plot showing the result of the UMAP dimensionality reduction method overlaid with the expression value of a chosen gene.

Moreover, we configure the second and third panel to use the gene (i.e., row) selected in the first panel.
This enables convenient examination of important markers when combined with sorting by $p$-value for a cluster of interest.


```r
initial.state <- list(
    RowDataTable(PanelId=1L),

    # Configure a "Feature assay plot" panel
    FeatureAssayPlot(
        YAxisFeatureSource="RowDataTable1",
        XAxis="Column data",
        XAxisColumnData="label",
        Assay="logcounts",
        DataBoxOpen=TRUE
    ),

    # Configure a "Reduced dimension plot" panel
    ReducedDimensionPlot(
        Type="UMAP",
        ColorBy="Feature name",
        ColorByFeatureSource="RowDataTable1",
        ColorByFeatureNameAssay="logcounts"
    )
)

# Prepare the app
app <- iSEE(copy.pbmc, initial=initial.state)
```

Once the application is launched, we sort the table by ascending value of "cluster1" to identify genes that are strong markers for cluster 1.
Then, users may select the first row in the _Row statistics table_ and watch the second and third panel automatically update to display the most significant marker gene on the y-axis (_Feature assay plot_) or as a color scale overlaid on the data points (_Reduced dimension plot_).
Alternatively, users can simply search the table for arbitrary gene names and select known markers for visualization.

### Querying features of interest

So far, the plots that we have examined have represented each column (i.e., cell) as a point.
However, it is straightforward to instead represent rows as points that can be selected and transmitted to eligible panels.
This is useful for more gene-centric exploratory analyses.
To illustrate, we will add variance modelling statistics to the `rowData()` of our `SingleCellExperiment` object.


```r
copy.pbmc <- sce.pbmc

# Adding some mean-variance information.
dec <- modelGeneVarByPoisson(copy.pbmc)
rowData(copy.pbmc) <- cbind(rowData(copy.pbmc), dec) 
```

The next code chunk sets up an app that contains:

1. A plot showing the mean-variance trend, where each point represents a cell.
2. A table of feature statistics, similar to that generated in the previous example.
3. A heatmap for the genes in the first plot.

We again configure the second and third panels to respond to the selection of points in the first panel.
This allows the user to select several highly variable genes at once and examine their statistics or expression profiles.
More advanced users can even configure the app to start with a brush or lasso to define a selection of genes at initialization.


```r
initial.state <- list(
    # Configure a "Feature assay plot" panel
    RowDataPlot(
        YAxis="total",
        XAxis="Row data",
        XAxisRowData="mean",
        PanelId=1L
    ),

    RowDataTable(
        RowSelectionSource="RowDataPlot1"
    ),

    # Configure a "ComplexHeatmap" panel
    ComplexHeatmapPlot(
        RowSelectionSource="RowDataPlot1",
        CustomRows=FALSE,
        ColumnData="label",
        Assay="logcounts",
        ClusterRows=TRUE,
        PanelHeight=800L,
        AssayCenterRows=TRUE
    )
)

# Prepare the app
app <- iSEE(copy.pbmc, initial=initial.state)
```

It is entirely possible for these row-centric panels to exist alongside the column-centric panels discussed previously.
The only limitation is that row-based panels cannot transmit multi-row selections to column-based panels and vice versa.
That said, a row-based panel can still transmit a single row selection to a column-based panel for, e.g., coloring by expression;
this allows us to set up an app where selecting a single HVG in the mean-variance plot causes the neighboring $t$-SNE to be colored by the expression of the selected gene.


```r
initial.state <- list(
    # Configure a "Feature assay plot" panel
    RowDataPlot(
        YAxis="total",
        XAxis="Row data",
        XAxisRowData="mean",
        PanelId=1L
    ),

    # Configure a "Reduced dimension plot" panel
    ReducedDimensionPlot(
        Type="TSNE",
        ColorBy="Feature name",
        ColorByFeatureSource="RowDataPlot1",
        ColorByFeatureNameAssay="logcounts"
    )
)

# Prepare the app
app <- iSEE(copy.pbmc, initial=initial.state)
```

## Reproducible visualizations

The state of the `iSEE` application can be saved at any point to provide a snapshot of the current view of the dataset.
This is achieved by clicking on the "Display panel settings" button under the "Export" dropdown menu in the top right corner and saving an RDS file containing a serialized list of panel parameters.
Anyone with access to this file and the original `SingleCellExperiment` can then run `iSEE` to recover the same application state. 
Alternatively, the code required to construct the panel parameters can be returned, which is more transparent and amenable to further modification.
This facility is most obviously useful for reproducing a perspective on the data that leads to a particular scientific conclusion;
it is also helpful for collaborations whereby different views of the same dataset can be easily transferred between analysts.

`iSEE` also keeps a record of the R commands used to generate each figure and table in the app.
This information is readily available via the "Extract the R code" button under the "Export" dropdown menu.
By copying the code displayed in the modal window and executing it in the R session from which the `iSEE` app was launched, a user can exactly reproduce all plots currently displayed in the GUI.
In this manner, a user can use `iSEE` to rapidly prototype plots of interest without having to write the associated boilerplate, after which they can then copy the code in an R script for fine-tuning.
Of course, the user can also save the plots and tables directly for further adjustment with other tools.

## Dissemination of analysis results {#dissemination}

`iSEE` provides a powerful avenue for disseminating results through a "guided tour" of the dataset.
This involves writing a step-by-step walkthrough of the different panels with explanations to facilitate their interpretation.
All that is needed to add a tour to an `iSEE` instance is a data frame with two columns named "element" and "intro"; the first column declares the UI element to highlight in each step of the tour, and the second one contains the text to display at that step.
This data frame must then be provided to the `iSEE()` function via the `tour` argument.
In the code chunk below, we demonstrate the implementation of a simple tour taking through the two panels that compose a GUI, and interactively train users to use the collapsible boxes.


```r
tour <- data.frame(
    element = c(
        "#Welcome",
        "#ReducedDimensionPlot1",
        "#ColumnDataPlot1",
        "#ColumnDataPlot1_DataBoxOpen",
        "#Conclusion"),
    intro = c(
        "Welcome to this tour!",
        "This is a <i>Reduced dimension plot.</i>",
        "And this is a <i>Column data plot.</i>",
        "<b>Action:</b> Click on this collapsible box to open and close it.",
        "Thank you for taking this tour!"),
    stringsAsFactors = FALSE)

initial.state <- list(
    ReducedDimensionPlot(PanelWidth=6L), 
    ColumnDataPlot(PanelWidth=6L)
)
```

The preconfigured Shiny app can then be loaded with the tour and launched as show below.
Note that the viewer is free to leave the interactive tour at any time and explore the data from their own perspective.
Examples of advanced tours showcasing a selection of published data sets can be found at https://github.com/iSEE/iSEE2018.


```r
iSEE(sce.pbmc, initial = initial.state, tour = tour)
```

## Additional resources

For demonstration and inspiration, we refer readers to the following examples of deployed applications:

- Use cases accompanying the published article: https://marionilab.cruk.cam.ac.uk/ (source code: https://github.com/iSEE/iSEE2018)
- Examples of `iSEE` in production: http://www.teichlab.org/singlecell-treg 
- Other examples as source code:
    - Gallery of examples notebooks to reproduce analyses on public data: https://github.com/iSEE/iSEE_instances
    - Gallery of example custom panels: https://github.com/iSEE/iSEE_custom 

## Session Info {-}

<button class="aaron-collapse">View session info</button>
<div class="aaron-content">
```
R Under development (unstable) (2020-03-23 r78035)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 18.04.4 LTS

Matrix products: default
BLAS:   /home/luna/Software/R/trunk/lib/libRblas.so
LAPACK: /home/luna/Software/R/trunk/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] scran_1.15.26               scater_1.15.29             
 [3] ggplot2_3.3.0               iSEE_1.99.6                
 [5] SingleCellExperiment_1.9.3  SummarizedExperiment_1.17.5
 [7] DelayedArray_0.13.8         matrixStats_0.56.0         
 [9] Biobase_2.47.3              GenomicRanges_1.39.3       
[11] GenomeInfoDb_1.23.16        IRanges_2.21.8             
[13] S4Vectors_0.25.14           BiocGenerics_0.33.3        
[15] OSCAUtils_0.0.2             BiocStyle_2.15.6           

loaded via a namespace (and not attached):
 [1] nlme_3.1-145             bitops_1.0-6             RColorBrewer_1.1-2      
 [4] tools_4.0.0              irlba_2.3.3              R6_2.4.1                
 [7] DT_0.13                  vipor_0.4.5              mgcv_1.8-31             
[10] colorspace_1.4-1         GetoptLong_0.1.8         withr_2.1.2             
[13] gridExtra_2.3            tidyselect_1.0.0         processx_3.4.2          
[16] compiler_4.0.0           cli_2.0.2                BiocNeighbors_1.5.2     
[19] shinyjs_1.1              colourpicker_1.0         bookdown_0.18           
[22] scales_1.1.0             callr_3.4.3              stringr_1.4.0           
[25] digest_0.6.25            rmarkdown_2.1            XVector_0.27.2          
[28] pkgconfig_2.0.3          htmltools_0.4.0          limma_3.43.5            
[31] fastmap_1.0.1            htmlwidgets_1.5.1        rlang_0.4.5             
[34] GlobalOptions_0.1.1      DelayedMatrixStats_1.9.1 shiny_1.4.0.2           
[37] shape_1.4.4              jsonlite_1.6.1           BiocParallel_1.21.2     
[40] dplyr_0.8.5              BiocSingular_1.3.2       RCurl_1.98-1.1          
[43] magrittr_1.5             GenomeInfoDbData_1.2.2   Matrix_1.2-18           
[46] ggbeeswarm_0.6.0         Rcpp_1.0.4               munsell_0.5.0           
[49] fansi_0.4.1              viridis_0.5.1            lifecycle_0.2.0         
[52] edgeR_3.29.1             stringi_1.4.6            yaml_2.2.1              
[55] rintrojs_0.2.2           zlibbioc_1.33.1          grid_4.0.0              
[58] dqrng_0.2.1              promises_1.1.0           shinydashboard_0.7.1    
[61] crayon_1.3.4             miniUI_0.1.1.1           lattice_0.20-40         
[64] splines_4.0.0            circlize_0.4.8           locfit_1.5-9.4          
[67] knitr_1.28               ComplexHeatmap_2.3.3     ps_1.3.2                
[70] pillar_1.4.3             igraph_1.2.5             rjson_0.2.20            
[73] codetools_0.2-16         glue_1.3.2               evaluate_0.14           
[76] BiocManager_1.30.10      png_0.1-7                vctrs_0.2.4             
[79] httpuv_1.5.2             gtable_0.3.0             purrr_0.3.3             
[82] clue_0.3-57              assertthat_0.2.1         xfun_0.12               
[85] rsvd_1.0.3               mime_0.9                 xtable_1.8-4            
[88] later_1.0.0              viridisLite_0.3.0        tibble_3.0.0            
[91] beeswarm_0.2.3           cluster_2.1.0            statmod_1.4.34          
[94] shinyWidgets_0.5.1       ellipsis_0.3.0           shinyAce_0.4.1          
```
</div>
